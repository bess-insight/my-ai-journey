# 250925
# ✅ data_path = "../../" 的真正含义是什么？
这是一个相对路径（relative path），它的作用是：
从当前 notebook 所在的文件夹，向上跳两级目录
然后把那个目录作为根目录，用于后续引用模块或数据。

# 250926-学习数据处理
# 📘 `lg_dataset.py` 逐行白话解释

```python
import numpy as np
import pandas as pd
import logging
import plotly.graph_objects as go
from sklearn.preprocessing import MinMaxScaler
from datetime import datetime, timedelta
```

* `numpy` → 用来处理矩阵和数组。
* `pandas` → 用来读 `.csv` 文件，处理表格数据。
* `logging` → 用来在运行时打印日志（比如提示有 NaN）。
* `plotly.graph_objects` → 画图用的库。
* `MinMaxScaler` → 本来用来做归一化（0–1 缩放），但在本文件里其实没用到。
* `datetime, timedelta` → 用来处理时间（比如把字符串时间转成秒数）。

---

```python
DATA_PATH = r'data/LG_18650HG2_Li-ion_Battery_Data/LG_HG2_Original_Dataset_McMasterUniversity_Jan_2020/'
```

* 定义了一个常量 `DATA_PATH`，保存电池数据存放的相对路径。
* `r''` 表示 raw string（避免路径里的反斜杠转义）。

---

## 定义类：`LgData`

```python
class LgData():
    def __init__(self, base_path="./"):
        self.path = base_path + DATA_PATH
        self.logger = logging.getLogger()
```

* `class LgData` → 定义了一个类，用来封装电池数据的读取和处理逻辑。
* `__init__` 是类的初始化函数：

  * `self.path` = `base_path` + `DATA_PATH`，组合出完整的数据目录；
  * `self.logger` = 日志工具，可以在运行时打印提示。

---

## 方法1：读取一个完整循环的数据

```python
def get_discharge_whole_cycle(self, train_names, test_names, output_capacity=False, scale_test=False, output_time=False):
    train = self._get_data(train_names, output_capacity, output_time)
    test = self._get_data(test_names, output_capacity, output_time)
    train, test = self._scale_x(train, test, scale_test=scale_test)        
    return (train, test)
```

* 定义了一个函数，用来加载训练集和测试集的所有循环数据。
* 输入参数：

  * `train_names` = 训练数据文件名列表
  * `test_names` = 测试数据文件名列表
  * `output_capacity=False` → 默认输出 SoC 百分比（如果设 True 就输出容量值）
  * `scale_test=False` → 默认不对测试数据做归一化
  * `output_time=False` → 默认不输出时间戳
* 执行逻辑：

  1. 用 `_get_data` 加载训练数据
  2. 用 `_get_data` 加载测试数据
  3. 用 `_scale_x` 对数据做归一化（0–1 缩放）
  4. 返回 `(train, test)`

---

## 方法2：读取数据文件

```python
def _get_data(self, names, output_capacity, output_time=False):
    cycles = []
    for name in names:
        cycle = pd.read_csv(self.path + name + '.csv', skiprows=30)
```

* `_get_data` 是一个“内部函数”（前面加 `_` 表示不建议外部直接调用）。
* `names` = 一批文件名。
* `pd.read_csv(...)` → 打开 CSV 文件，跳过前 30 行（通常是元数据）。

```python
        cycle.columns = ['Time Stamp','Step','Status','Prog Time','Step Time','Cycle',
                        'Cycle Level','Procedure','Voltage','Current','Temperature','Capacity','WhAccu','Cnt','Empty']
```

* 给 CSV 数据加上列名。
* 常见字段：电压、电流、温度、容量、时间戳。

```python
        cycle = cycle[(cycle["Status"] == "TABLE") | (cycle["Status"] == "DCH")]
```

* 过滤数据，只保留“放电阶段”。
* “DCH”=Discharge，“TABLE”=稳定表格数据。

---

### SoC 计算逻辑

```python
        max_discharge = abs(min(cycle["Capacity"]))
        cycle["SoC Capacity"] = max_discharge + cycle["Capacity"]
        cycle["SoC Percentage"] = cycle["SoC Capacity"] / max(cycle["SoC Capacity"])
```

* `Capacity` 在 CSV 里可能是负值（放电）。
* `SoC Capacity` = “最大放电量 + 当前容量”，让它从 0 开始增加。
* `SoC Percentage` = 用 `SoC Capacity / 最大值` 转成 0–1 范围。

---

### 提取输入和输出

```python
        x = cycle[["Voltage", "Current", "Temperature"]].to_numpy()
```

* `x` = 输入特征矩阵（三列：电压、电流、温度）。

```python
        if output_capacity:
            y = cycle[["SoC Capacity"]].to_numpy()
        else:
            y = cycle[["SoC Percentage"]].to_numpy()
```

* `y` = 输出标签：SoC 容量或百分比。

---

### 清理 NaN

```python
        if np.isnan(np.min(x)) or np.isnan(np.min(y)):
            self.logger.info("There is a NaN in cycle " + name + ", removing row")
            x = x[~np.isnan(x).any(axis=1)]
            y = y[~np.isnan(y).any(axis=1)].reshape(-1, y.shape[1])
```

* 如果有缺失值（NaN），删除对应行。
* 避免模型训练时报错。

---

### 收集结果

```python
        cycles.append((x, y))
    return cycles
```

* 把当前循环的 `(x, y)` 存入列表 `cycles`。
* 最终返回一个列表，里面是所有循环的数据对。

---

## 方法3：归一化特征

```python
def _scale_x(self, train, test, scale_test=False):
    for index_feature in range(len(train[0][0][0])):
        feature_min = min([min(cycle[0][:,index_feature]) for cycle in train])
        feature_max = max([max(cycle[0][:,index_feature]) for cycle in train])
        for i in range(len(train)):
            train[i][0][:,index_feature] = (train[i][0][:,index_feature]-feature_min)/(feature_max-feature_min)
        if scale_test:
            for i in range(len(test)):
                test[i][0][:,index_feature] = (test[i][0][:,index_feature]-feature_min)/(feature_max-feature_min)
    return train, test
```

* 对 `train` 中的每个特征列（电压、电流、温度）做 min-max 缩放：

  ```text
  (value - min) / (max - min) → 范围变成 0–1
  ```
* 如果 `scale_test=True`，则用相同的 `min/max` 对测试数据也做缩放。

---

👉 Jason，这个文件后面还有 `get_stateful_cycle`、`get_discharge_multiple_step` 等函数，我可以继续逐行拆给你，保持这种“逐行白话+语法补课”的风格。

你想让我现在接着把 **“数据切片（滑动窗口）部分”** 继续解释吗？

